use std::fmt::Display;

use itertools::Itertools;
use ndarray::s;
use ndarray::Array1;
use ndarray::ArrayView1;
use ndarray::ArrayView2;
use ndarray::ArrayViewMut2;
use twenty_first::shared_math::b_field_element::BFieldElement;
use twenty_first::shared_math::mpolynomial::Degree;
use twenty_first::shared_math::x_field_element::XFieldElement;

use crate::arithmetic_domain::ArithmeticDomain;
use crate::table::table_collection::interpolant_degree;

use super::base_table::TableLike;
use super::challenges::AllChallenges;

// Generic methods specifically for tables that have been extended

pub trait ExtensionTable: TableLike<XFieldElement> + Sync {}

const ERROR_MESSAGE_GENERATE_CONSTRAINTS: &str =
    "Constraints must be in place. Run: `cargo run --bin constraint-evaluation-generator`";
const ERROR_MESSAGE_GENERATE_DEGREE_BOUNDS: &str =
    "Degree bounds must be in place. Run: `cargo run --bin constraint-evaluation-generator`";

pub trait Evaluable: ExtensionTable {
    /// The code for this method must be generated by running
    /// `cargo run --bin constraint-evaluation-generator`
    fn evaluate_initial_constraints(
        _base_row: ArrayView1<BFieldElement>,
        _ext_row: ArrayView1<XFieldElement>,
        _challenges: &AllChallenges,
    ) -> Vec<XFieldElement> {
        panic!("{ERROR_MESSAGE_GENERATE_CONSTRAINTS}")
    }

    /// The code for this method must be generated by running
    /// `cargo run --bin constraint-evaluation-generator`
    fn evaluate_consistency_constraints(
        _base_row: ArrayView1<BFieldElement>,
        _ext_row: ArrayView1<XFieldElement>,
        _challenges: &AllChallenges,
    ) -> Vec<XFieldElement> {
        panic!("{ERROR_MESSAGE_GENERATE_CONSTRAINTS}")
    }

    /// The code for this method must be generated by running
    /// `cargo run --bin constraint-evaluation-generator`
    fn evaluate_transition_constraints(
        _current_base_row: ArrayView1<BFieldElement>,
        _current_ext_row: ArrayView1<XFieldElement>,
        _next_base_row: ArrayView1<BFieldElement>,
        _next_ext_row: ArrayView1<XFieldElement>,
        _challenges: &AllChallenges,
    ) -> Vec<XFieldElement> {
        panic!("{ERROR_MESSAGE_GENERATE_CONSTRAINTS}")
    }

    /// The code for this method must be generated by running
    /// `cargo run --bin constraint-evaluation-generator`
    fn evaluate_terminal_constraints(
        _base_row: ArrayView1<BFieldElement>,
        _ext_row: ArrayView1<XFieldElement>,
        _challenges: &AllChallenges,
    ) -> Vec<XFieldElement> {
        panic!("{ERROR_MESSAGE_GENERATE_CONSTRAINTS}")
    }
}

pub trait Quotientable: ExtensionTable + Evaluable {
    /// Compute the degrees of the quotients from all AIR constraints that apply to the table.
    fn all_degrees_with_origin(
        table_name: &str,
        padded_height: usize,
        num_trace_randomizers: usize,
    ) -> Vec<DegreeWithOrigin> {
        let initial_degrees_with_origin =
            Self::initial_quotient_degree_bounds(padded_height, num_trace_randomizers)
                .into_iter()
                .enumerate()
                .map(|(i, d)| DegreeWithOrigin {
                    degree: d,
                    zerofier_degree: 1,
                    origin_table_name: table_name.to_owned(),
                    origin_index: i,
                    origin_table_height: padded_height,
                    origin_num_trace_randomizers: num_trace_randomizers,
                    origin_constraint_type: "initial constraint".to_string(),
                })
                .collect_vec();

        let consistency_degrees_with_origin =
            Self::consistency_quotient_degree_bounds(padded_height, num_trace_randomizers)
                .into_iter()
                .enumerate()
                .map(|(i, d)| DegreeWithOrigin {
                    degree: d,
                    zerofier_degree: padded_height as Degree,
                    origin_table_name: table_name.to_owned(),
                    origin_index: i,
                    origin_table_height: padded_height,
                    origin_num_trace_randomizers: num_trace_randomizers,
                    origin_constraint_type: "consistency constraint".to_string(),
                })
                .collect();

        let transition_degrees_with_origin =
            Self::transition_quotient_degree_bounds(padded_height, num_trace_randomizers)
                .into_iter()
                .enumerate()
                .map(|(i, d)| DegreeWithOrigin {
                    degree: d,
                    zerofier_degree: padded_height as Degree - 1,
                    origin_table_name: table_name.to_owned(),
                    origin_index: i,
                    origin_table_height: padded_height,
                    origin_num_trace_randomizers: num_trace_randomizers,
                    origin_constraint_type: "transition constraint".to_string(),
                })
                .collect();

        let terminal_degrees_with_origin =
            Self::terminal_quotient_degree_bounds(padded_height, num_trace_randomizers)
                .into_iter()
                .enumerate()
                .map(|(i, d)| DegreeWithOrigin {
                    degree: d,
                    zerofier_degree: 1,
                    origin_table_name: table_name.to_owned(),
                    origin_index: i,
                    origin_table_height: padded_height,
                    origin_num_trace_randomizers: num_trace_randomizers,
                    origin_constraint_type: "terminal constraint".to_string(),
                })
                .collect();

        [
            initial_degrees_with_origin,
            consistency_degrees_with_origin,
            transition_degrees_with_origin,
            terminal_degrees_with_origin,
        ]
        .concat()
    }

    fn fill_initial_quotients(
        master_base_table: ArrayView2<BFieldElement>,
        master_ext_table: ArrayView2<XFieldElement>,
        quot_table: &mut ArrayViewMut2<XFieldElement>,
        zerofier_inverse: ArrayView1<BFieldElement>,
        challenges: &AllChallenges,
    ) {
        debug_assert_eq!(zerofier_inverse.len(), master_base_table.nrows());
        debug_assert_eq!(zerofier_inverse.len(), master_ext_table.nrows());

        zerofier_inverse
            .into_iter() // todo: into_par_iter – but how?
            .enumerate()
            .for_each(|(domain_index, &z_inv)| {
                let mut quotient_table_row = Array1::from(Self::evaluate_initial_constraints(
                    master_base_table.slice(s![domain_index, ..]),
                    master_ext_table.slice(s![domain_index, ..]),
                    challenges,
                ));
                quotient_table_row.mapv_inplace(|a| a * z_inv);
                quotient_table_row.move_into(quot_table.row_mut(domain_index));
            });
    }

    fn fill_consistency_quotients(
        master_base_table: ArrayView2<BFieldElement>,
        master_ext_table: ArrayView2<XFieldElement>,
        quot_table: &mut ArrayViewMut2<XFieldElement>,
        zerofier_inverse: ArrayView1<BFieldElement>,
        challenges: &AllChallenges,
    ) {
        debug_assert_eq!(zerofier_inverse.len(), master_base_table.nrows());
        debug_assert_eq!(zerofier_inverse.len(), master_ext_table.nrows());

        zerofier_inverse
            .into_iter() // todo: into_par_iter – but how?
            .enumerate()
            .for_each(|(domain_index, &z_inv)| {
                let mut quotient_table_row = Array1::from(Self::evaluate_consistency_constraints(
                    master_base_table.slice(s![domain_index, ..]),
                    master_ext_table.slice(s![domain_index, ..]),
                    challenges,
                ));
                quotient_table_row.mapv_inplace(|a| a * z_inv);
                quotient_table_row.move_into(quot_table.row_mut(domain_index));
            });
    }

    fn fill_transition_quotients(
        master_base_table: ArrayView2<BFieldElement>,
        master_ext_table: ArrayView2<XFieldElement>,
        quot_table: &mut ArrayViewMut2<XFieldElement>,
        zerofier_inverse: ArrayView1<BFieldElement>,
        challenges: &AllChallenges,
        quotient_domain: ArithmeticDomain,
        padded_height: usize,
    ) {
        debug_assert_eq!(zerofier_inverse.len(), master_base_table.nrows());
        debug_assert_eq!(zerofier_inverse.len(), master_ext_table.nrows());

        // the relation between the quotient domain and the trace domain
        let unit_distance = quotient_domain.length / padded_height;

        let domain_length_bit_mask = quotient_domain.length - 1;
        zerofier_inverse
            .into_iter() // todo: into_par_iter – but how?
            .enumerate()
            .for_each(|(current_row_index, &z_inv)| {
                // `&domain_length_bit_mask` performs the modulo operation cheaply:
                // `domain.length - 1` is a bit-mask with all 1s because `domain.length` is 2^k
                // for some k.
                let next_row_index = (current_row_index + unit_distance) & domain_length_bit_mask;
                let current_base_row = master_base_table.slice(s![current_row_index, ..]);
                let current_ext_row = master_ext_table.slice(s![current_row_index, ..]);
                let next_base_row = master_base_table.slice(s![next_row_index, ..]);
                let next_ext_row = master_ext_table.slice(s![next_row_index, ..]);
                let mut quotient_table_row = Array1::from(Self::evaluate_transition_constraints(
                    current_base_row,
                    current_ext_row,
                    next_base_row,
                    next_ext_row,
                    challenges,
                ));
                quotient_table_row.mapv_inplace(|a| a * z_inv);
                quotient_table_row.move_into(quot_table.row_mut(current_row_index));
            });
    }

    fn fill_terminal_quotients(
        master_base_table: ArrayView2<BFieldElement>,
        master_ext_table: ArrayView2<XFieldElement>,
        quot_table: &mut ArrayViewMut2<XFieldElement>,
        zerofier_inverse: ArrayView1<BFieldElement>,
        challenges: &AllChallenges,
    ) {
        debug_assert_eq!(zerofier_inverse.len(), master_base_table.nrows());
        debug_assert_eq!(zerofier_inverse.len(), master_ext_table.nrows());

        zerofier_inverse
            .into_iter() // todo: into_par_iter – but how?
            .enumerate()
            .for_each(|(domain_index, &z_inv)| {
                let mut quotient_table_row = Array1::from(Self::evaluate_terminal_constraints(
                    master_base_table.slice(s![domain_index, ..]),
                    master_ext_table.slice(s![domain_index, ..]),
                    challenges,
                ));
                quotient_table_row.mapv_inplace(|a| a * z_inv);
                quotient_table_row.move_into(quot_table.row_mut(domain_index));
            });
    }

    fn initial_quotient_degree_bounds(
        _padded_height: usize,
        _num_trace_randomizers: usize,
    ) -> Vec<Degree> {
        panic!("{ERROR_MESSAGE_GENERATE_DEGREE_BOUNDS}")
    }

    fn consistency_quotient_degree_bounds(
        _padded_height: usize,
        _num_trace_randomizers: usize,
    ) -> Vec<Degree> {
        panic!("{ERROR_MESSAGE_GENERATE_DEGREE_BOUNDS}")
    }

    fn transition_quotient_degree_bounds(
        _padded_height: usize,
        _num_trace_randomizers: usize,
    ) -> Vec<Degree> {
        panic!("{ERROR_MESSAGE_GENERATE_DEGREE_BOUNDS}")
    }

    fn terminal_quotient_degree_bounds(
        _padded_height: usize,
        _num_trace_randomizers: usize,
    ) -> Vec<Degree> {
        panic!("{ERROR_MESSAGE_GENERATE_DEGREE_BOUNDS}")
    }
}
pub trait QuotientableExtensionTable: ExtensionTable + Quotientable {}

/// Helps debugging and benchmarking. The maximal degree achieved in any table dictates the length
/// of the FRI domain, which in turn is responsible for the main performance bottleneck.
#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Debug)]
pub struct DegreeWithOrigin {
    pub degree: Degree,
    pub zerofier_degree: Degree,
    pub origin_table_name: String,
    pub origin_index: usize,
    pub origin_table_height: usize,
    pub origin_num_trace_randomizers: usize,
    pub origin_constraint_type: String,
}

impl Default for DegreeWithOrigin {
    fn default() -> Self {
        DegreeWithOrigin {
            degree: -1,
            zerofier_degree: -1,
            origin_table_name: "NoTable".to_string(),
            origin_index: usize::MAX,
            origin_table_height: 0,
            origin_num_trace_randomizers: 0,
            origin_constraint_type: "NoType".to_string(),
        }
    }
}

impl Display for DegreeWithOrigin {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let interpolant_degree =
            interpolant_degree(self.origin_table_height, self.origin_num_trace_randomizers);
        let zerofier_corrected_degree = self.degree + self.zerofier_degree;
        assert_eq!(0, zerofier_corrected_degree % interpolant_degree); // todo: wtf – in Display?!
        let degree = zerofier_corrected_degree / interpolant_degree as Degree;
        write!(
            f,
            "Degree of poly for table {} (index {:02}) of type {} is {}.",
            self.origin_table_name, self.origin_index, self.origin_constraint_type, degree,
        )
    }
}
